<!DOCTYPE html>
<html lang="fr">
<head>
    <title>three.js webgl - geometry - cube</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>
<body>

<div class="terminal" id="terminal" style="position: absolute;top: 18%; left: 35%;display: none;">
<img src="images/terminal.png" alt="Terminal de paiement" width="600" height="600">
</div>

<style>

    html, body {
        padding: 0;
        margin: 0;
        overflow: hidden;
    }

</style>


<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"GLTFLoader": "./jsm/loaders/GLTFLoader.js",
					"OrbitControl": "./jsm/controls/OrbitControls.js",
					"Stats": "./jsm/libs/stats.module.js",
					"GUI": "./jsm/libs/lil-gui.module.min.js",
					"DRACOLoader": "./jsm/loaders/DRACOLoader.js",
					"FirstPersonControls": "./jsm/controls/FirstPersonControls.js"
				}
			}

</script>


<script type="module">

    import * as THREE from 'three';

    import Stats from 'Stats';

    import {OrbitControls} from 'OrbitControl';

    import { FirstPersonControls } from 'FirstPersonControls';

    import { GLTFLoader } from 'GLTFLoader';

    import { DRACOLoader } from 'DRACOLoader';


    let camera, scene, renderer, startTime, stats, controls,
        leftWallposition, rightWallposition, frontWallposition, backWallposition,
        object, clipMaterial,
        volumeVisualization,
        globalClippingPlanes;

    const clock = new THREE.Clock();
    const imgTerminal = document.getElementById('terminal');

    function init() {

        camera = new THREE.PerspectiveCamera(
            36, window.innerWidth / window.innerHeight, 0.25, 10000);

        camera.position.set(0, 120, 140);

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        // Lights

        scene.add(new THREE.AmbientLight(0xffffff, 0.3));

        const spotLight = new THREE.SpotLight(0xffffff, 0.5);
        spotLight.angle = Math.PI / 5;
        spotLight.penumbra = 0.2;
        spotLight.position.set(2, 3, 3);
        spotLight.castShadow = true;
        spotLight.shadow.camera.near = 3;
        spotLight.shadow.camera.far = 10;
        spotLight.shadow.mapSize.width = 1024;
        spotLight.shadow.mapSize.height = 1024;
        scene.add(spotLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(0, 2, 0);
        dirLight.castShadow = true;
        dirLight.shadow.camera.near = 1;
        dirLight.shadow.camera.far = 10;

        dirLight.shadow.camera.right = 1;
        dirLight.shadow.camera.left = -1;
        dirLight.shadow.camera.top = 1;
        dirLight.shadow.camera.bottom = -1;

        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // Mur autour de la store pour pas pouvoir tomber

        // Mur gauche (invisible)
        const leftWall = new THREE.Mesh(new THREE.BoxGeometry(1,100,500), new THREE.MeshPhysicalMaterial( {
            color : 0x87ceeb,
            metalness: 0,
            roughness: 0,
            transmission: 1,
            opacity : 0,
            transparent: true
        } ));
        leftWall.position.set(-130, 0, 0);
        leftWall.castShadow = true;
        leftWall.receiveShadow = true;
        scene.add(leftWall);
        leftWallposition = leftWall.position.clone();

        let leftWallBB = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
        leftWallBB.setFromObject(leftWall);
        console.log(leftWallBB);


        // Mur droit (invisible)
        const rightWall = new THREE.Mesh(new THREE.BoxGeometry(1,100,500), new THREE.MeshPhysicalMaterial( {
            color : 0x87ceeb,
            metalness: 0,
            roughness: 0,
            transmission: 1,
            opacity : 0,
            transparent: true
        }));
        rightWall.position.set(130, 0, 0);
        rightWall.castShadow = true;
        rightWall.receiveShadow = true;
        scene.add(rightWall);
        rightWallposition = rightWall.position.clone();

        let rightWallBB = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
        rightWallBB.setFromObject(rightWall);
        console.log(rightWallBB);

        // Mur arrière (invisible)
        const backWall = new THREE.Mesh(new THREE.BoxGeometry(260,100,1), new THREE.MeshPhysicalMaterial( {
            color : 0x87ceeb,
            metalness: 0,
            roughness: 0,
            transmission: 1,
            opacity : 0,
            transparent: true
        } ));
        backWall.position.set(0, 0, -200);
        backWall.castShadow = true;
        backWall.receiveShadow = true;
        scene.add(backWall);
        backWallposition = backWall.position.clone();

        let backWallBB = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
        backWallBB.setFromObject(backWall);
        console.log(backWallBB);

        // Mur avant (invisible)
        const frontWall = new THREE.Mesh(new THREE.BoxGeometry(260,100,1), new THREE.MeshPhysicalMaterial( {
            color : 0x87ceeb,
            metalness: 0,
            roughness: 0,
            transmission: 1,
            opacity : 0,
            transparent: true
        } ));
        frontWall.position.set(0, 0, 200);
        frontWall.castShadow = true;
        frontWall.receiveShadow = true;
        scene.add(frontWall);
        frontWallposition = frontWall.position.clone();

        let frontWallBB = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
        frontWallBB.setFromObject(frontWall);
        console.log(frontWallBB);


        // LOAD THE STORE MODEL

        // Instantiate a loader
        const loader = new GLTFLoader();

        // Optional: Provide a DRACOLoader instance to decode compressed mesh data
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath( '/gltf/' );
        loader.setDRACOLoader( dracoLoader );

        // Load a glTF resource
        loader.load(
            // resource URL
            './gltf/scene.gltf',
            // called when the resource is loaded
            function ( gltf ) {

                let store = gltf.scene
                store.position.y = 1;
                store.receiveShadow = true;
                store.castShadow = true;

                scene.add( store );

            },
            // called while loading is progressing
            function ( xhr ) {

                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

            },
            // called when loading has errors
            function ( error ) {

                console.log( 'An error happened' );

            }
        );


        // GROUND


        const planeGeometry = new THREE.BoxGeometry(260, 400, 1, 1);

        // Texture du sol
        const textureSol = new THREE.TextureLoader().load('./textures/texture-sol.jpg');
        textureSol.wrapS = THREE.RepeatWrapping;
        textureSol.wrapT = THREE.RepeatWrapping;
        textureSol.repeat.set( 12, 12 );

        const groundMaterial = new THREE.MeshPhongMaterial( { map:textureSol });

        const ground = new THREE.Mesh(planeGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Renderer

        const container = document.body;

        renderer = new THREE.WebGLRenderer();
        renderer.shadowMap.enabled = true;
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        window.addEventListener('resize', onWindowResize);
        container.appendChild(renderer.domElement);
        // Clipping setup:
        renderer.localClippingEnabled = true;

        // Instanciate the FirstPersonControls
        controls = new FirstPersonControls( camera, renderer.domElement );
        controls.movementSpeed = 50;
        controls.lookSpeed = 0.1;
        controls.activeLook = true;

        //controls = new OrbitControls( camera, renderer.domElement );
        //controls.update();

        // Stats

        stats = new Stats();
        container.appendChild(stats.dom);


        // Start

        startTime = Date.now();

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

    }


    function animate() {

        requestAnimationFrame(animate);
        camera.position.y = 20;

        var origin = camera.position.clone();

        // Collision sur le mur gauche pour empêcher le personnage de sortir de la scène
        if (camera.position.x < -120) {
            camera.position.x = -120;
        }
        // Collision sur le mur droit pour empêcher le personnage de sortir de la scène
        if (camera.position.x > 120) {
            camera.position.x = 120;
        }
        // Collision sur le mur bas pour empêcher le personnage de sortir de la scène
        if (camera.position.z < -185) {
            camera.position.z = -185;
        }
        // Collision sur le mur haut pour empêcher le personnage de sortir de la scène
        if (camera.position.z > 185) {
            camera.position.z = 185;
        }

        // Collision sur la porte du modèle de magasin
        if (camera.position.x < 1 && camera.position.z < 29) {
            controls.activeLook = false;
            controls.dispose();
            camera.position.x = 0;
            camera.position.z = 140;

            imgTerminal.style.display = "block";

        }

        stats.begin();
        render();
        renderer.render(scene, camera);
        stats.end();

    }

    function render() {

        controls.update( clock.getDelta() );
        renderer.render(scene, camera);

    }

    init();
    animate();

</script>

</body>
</html>